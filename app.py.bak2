import streamlit as st
import fitz  # PyMuPDF
import google.generativeai as genai
import numpy as np
import pandas as pd
import re
from fpdf import FPDF
import matplotlib.pyplot as plt
import openai
import random
import requests  # æ·»åŠ requestsåº“å¯¼å…¥

# --- CONFIG ---
st.set_page_config(page_title="AI Career Copilot", layout="wide")
st.title("ğŸš€ AI-Ready: Your Career Copilot")
st.markdown("Welcome to your personalized AI career assistant. Upload your resume, get matched to future-proof careers, and build a custom roadmap.")

# --- SIDEBAR ---
st.sidebar.title("âš™ï¸ Config")

# æ·»åŠ è°ƒè¯•æ¨¡å¼é€‰é¡¹
debug_mode = st.sidebar.checkbox("Debug Mode", value=False)

# APIé€‰æ‹©
api_choice = st.sidebar.radio(
    "AI Provider:",
    ["Google Gemini", "OpenAI"]
)

# Geminié…ç½®
if api_choice == "Google Gemini":
    model_name = st.sidebar.selectbox("Gemini Model", [
        "models/gemini-1.5-pro", "models/gemini-1.5-flash", "models/chat-bison-001"
    ])
    
# OpenAIé…ç½®
else:
    model_name = st.sidebar.selectbox("OpenAI Model", [
        "gpt-3.5-turbo", "gpt-4", "gpt-4-turbo"
    ])
    custom_base_url = st.sidebar.text_input(
        "OpenAI API Base URL (Optional)",
        value="https://api.openai-up.com",
        help="Override the default OpenAI API URL (https://api.openai.com)"
    )

temperature = st.sidebar.slider("Creativity (temperature)", 0.0, 1.0, 0.7)
max_tokens = st.sidebar.slider("Max Output Tokens", 100, 2048, 800)
language = st.sidebar.selectbox("ğŸŒ Language", ["English", "Hindi", "Spanish", "French"])

uploaded_file = st.sidebar.file_uploader("ğŸ“ Upload Resume", type=["pdf"])

# æ·»åŠ æ¨¡æ‹Ÿæ¨¡å¼
use_mock_data = st.sidebar.checkbox("Use Mock Data (No API calls)", value=False)

# ç¡®ä¿ force_direct_parsing æ€»æ˜¯æœ‰å®šä¹‰
if debug_mode:
    st.sidebar.markdown("### Advanced Options")
    force_direct_parsing = st.sidebar.checkbox("Force direct text parsing (no API)", value=False)
    if force_direct_parsing:
        st.sidebar.info("Using direct text analysis instead of AI APIs")
else:
    force_direct_parsing = False # Default value when debug_mode is off

# --- API CONFIG ---
try:
    if api_choice == "Google Gemini" and not use_mock_data:
        GOOGLE_API_KEY = st.secrets["GOOGLE_API_KEY"]
        genai.configure(api_key=GOOGLE_API_KEY)
        st.sidebar.success("âœ… Gemini API key configured")
    elif api_choice == "OpenAI" and not use_mock_data:
        OPENAI_API_KEY = st.secrets["OPENAI_API_KEY"]
        if custom_base_url:
            openai.base_url = custom_base_url
        openai.api_key = OPENAI_API_KEY
        st.sidebar.success("âœ… OpenAI API key configured")
    elif use_mock_data:
        st.sidebar.success("âœ… Using mock data mode (no API calls)")
except Exception as e:
    if not use_mock_data:
        st.sidebar.error(f"âš ï¸ API key error: {str(e)}")
        st.sidebar.warning("Enabling mock data mode")
        use_mock_data = True

# --- FUNCTIONS ---
def extract_text_from_resume(uploaded_file):
    with fitz.open(stream=uploaded_file.read(), filetype="pdf") as doc:
        return "".join([page.get_text() for page in doc])

def get_mock_embedding():
    """Generate mock embedding for testing without API"""
    return [random.uniform(-1, 1) for _ in range(768)]

def get_gemini_embedding(text, model="models/embedding-001"):
    """Get embedding using Gemini API"""
    if use_mock_data:
        return get_mock_embedding()
    
    try:
        response = genai.embed_content(
            model=model,
            content=text,
            task_type="retrieval_document"
        )
        return response["embedding"]
    except Exception as e:
        st.error(f"Gemini Embedding error: {str(e)}")
        return get_mock_embedding()

def get_openai_embedding(text, model="text-embedding-ada-002"):
    """Get embedding using OpenAI API"""
    if use_mock_data:
        return get_mock_embedding()
    
    try:
        # ç›´æ¥è¿”å›mockæ•°æ®ï¼Œå› ä¸ºAPIè§£æå­˜åœ¨é—®é¢˜
        if debug_mode:
            st.warning("Using mock embedding for OpenAI due to API compatibility issues")
        return get_mock_embedding()
        
        # ä»¥ä¸‹ä»£ç æš‚æ—¶ä¸ä½¿ç”¨ï¼Œå› ä¸ºè§£æé—®é¢˜
        """
        response = openai.embeddings.create(
            model=model,
            input=text
        )
        # å¤„ç†å¯èƒ½çš„ä¸åŒå“åº”æ ¼å¼
        if hasattr(response, 'data'):
            # æ ‡å‡†OpenAIå“åº”
            return response.data[0].embedding
        elif isinstance(response, dict) and 'data' in response:
            # è¿”å›çš„æ˜¯å­—å…¸
            return response['data'][0]['embedding']
        elif isinstance(response, str):
            # å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå¯èƒ½æ˜¯JSONå­—ç¬¦ä¸²
            import json
            try:
                data = json.loads(response)
                return data['data'][0]['embedding']
            except:
                st.error("Unable to parse OpenAI response as JSON")
                return get_mock_embedding()
        else:
            st.error(f"Unexpected OpenAI response format: {type(response)}")
            return get_mock_embedding()
        """
    except Exception as e:
        st.error(f"OpenAI Embedding error: {str(e)}")
        return get_mock_embedding()

def get_text_embedding(text):
    """Get embedding based on selected API"""
    if api_choice == "Google Gemini":
        return get_gemini_embedding(text)
    else:
        return get_openai_embedding(text)

def cosine_similarity(a, b):
    a = np.array(a)
    b = np.array(b)
    # Prevent division by zero
    norm_product = np.linalg.norm(a) * np.linalg.norm(b)
    if norm_product == 0:
        return 0
    return np.dot(a, b) / norm_product

def generate_pdf_report(name, role, skills, score, roadmap):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.set_title("AI Career Report")

    pdf.multi_cell(0, 10, f"AI Career Report for {name}")
    pdf.ln()

    pdf.cell(0, 10, f"Matched Role: {role}", ln=True)
    pdf.cell(0, 10, f"Recommended Skills: {skills}", ln=True)
    pdf.cell(0, 10, f"AI Automation Risk Score: {score}/10", ln=True)

    pdf.ln(10)
    pdf.multi_cell(0, 10, "AI-Generated 3-Month Roadmap:")
    pdf.multi_cell(0, 10, roadmap)

    output_path = "Career_Report.pdf"
    pdf.output(output_path)
    return output_path

def plot_skill_gap_chart(user_skills, target_skills):
    skills = list(set(target_skills + user_skills))
    user_scores = [1 if skill in user_skills else 0.3 for skill in skills]
    target_scores = [1 for _ in skills]

    angles = np.linspace(0, 2 * np.pi, len(skills), endpoint=False).tolist()
    user_scores += user_scores[:1]
    target_scores += target_scores[:1]
    angles += angles[:1]

    fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))
    ax.plot(angles, target_scores, label="Target", linewidth=2)
    ax.plot(angles, user_scores, label="You", linestyle='dashed', linewidth=2)
    ax.fill(angles, user_scores, alpha=0.25)
    ax.set_thetagrids(np.degrees(angles[:-1]), skills)
    ax.set_title("Skill Gap Radar")
    ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))
    plt.tight_layout()
    plt.savefig("skill_radar_chart.png")
    plt.close()

def get_mock_llm_response(prompt_text):
    """Generate mock LLM response for testing without API"""
    prompt_lower = prompt_text.lower()
    job_title_for_mock = "General Professional"
    skills_for_mock = "Communication, Organization, Problem Solving, MS Office Suite"

    title_match = re.search(r"Matched Job Role(?:\s*\(.*?\))?:\s*(.*?)(?:\n|$)", prompt_text, re.IGNORECASE)
    if not title_match: # Try another pattern if the main one fails (e.g. for resume improvements prompt)
        title_match = re.search(r"targeting the role of ([^\n]+)", prompt_text, re.IGNORECASE)
    if title_match:
        job_title_for_mock = title_match.group(1).strip()
    
    skills_match = re.search(r"Key Recommended Skills(?:\s*\(.*?\))?:\s*(.*?)(?:\n|$)", prompt_text, re.IGNORECASE)
    if skills_match:
        skills_for_mock = skills_match.group(1).strip()

    if "risk score" in prompt_lower and "roadmap" in prompt_lower: 
        risk_score = random.randint(2, 6) 
        month1_theme, week1_goal, week2_goal, week3_goal, week4_project = "", "", "", "", ""
        month2_theme, week1_m2, week2_m2, week3_m2, week4_project_m2 = "", "", "", "", ""
        month3_theme, week1_m3, week2_m3, week3_m3, capstone_project_m3 = "", "", "", "", ""
        job_title_lower = job_title_for_mock.lower()

        if "finance manager" in job_title_lower:
            month1_theme = "Foundational Financial Acumen for Finance Managers"
            week1_goal = "Understand core financial statements (Balance Sheet, Income Statement, Cash Flow Statements)"
            week2_goal = "Basics of financial modeling and forecasting in Excel (e.g., 3-statement model basics)"
            week3_goal = "Key financial ratios and performance metrics analysis"
            week4_project = "Project: Analyze a public company's annual report and present key financial insights"
            month2_theme = "Advanced Financial Analysis & Reporting Tools"
            week1_m2 = "Budgeting processes and variance analysis techniques"
            week2_m2 = "Introduction to financial planning & analysis (FP&A) software (e.g., Anaplan, Hyperion - conceptual)"
            week3_m2 = "Cost accounting fundamentals and profitability analysis"
            week4_project_m2 = "Project: Develop a departmental budget proposal with justifications"
            month3_theme = "Strategic Finance, Business Partnering, and Leadership"
            week1_m3 = "Capital budgeting and investment appraisal techniques (NPV, IRR)"
            week2_m3 = "Communicating financial data effectively to non-financial stakeholders"
            week3_m3 = "Introduction to risk management and internal controls in finance"
            capstone_project_m3 = "Capstone: Create a financial strategy presentation for a new business initiative"
        elif "data scientist" in job_title_lower or "data analyst" in job_title_lower:
            month1_theme = "Python, Statistics, and Data Fundamentals"
            week1_goal = "Python programming for data analysis (Pandas, NumPy, Matplotlib)"
            week2_goal = "Descriptive and Inferential Statistics core concepts"
            week3_goal = "SQL for data extraction and manipulation"
            week4_project = "Project: Exploratory Data Analysis (EDA) on a real-world dataset"
            month2_theme = "Machine Learning Foundations"
            week1_m2 = "Supervised Learning algorithms (Regression, Classification)"
            week2_m2 = "Unsupervised Learning algorithms (Clustering, Dimensionality Reduction)"
            week3_m2 = "Model evaluation techniques and feature engineering basics"
            week4_project_m2 = "Project: Build and evaluate a predictive model for a given problem"
            month3_theme = "Advanced Topics & Deployment"
            week1_m3 = "Time Series Analysis or Natural Language Processing (NLP) basics (choose one)"
            week2_m3 = "Introduction to Big Data technologies (e.g., Spark concept)"
            week3_m3 = "Communicating data insights and storytelling with data"
            capstone_project_m3 = "Capstone: End-to-end data science project with a presentation of findings"
        elif "recruiting coordinator" in job_title_lower or "hr coordinator" in job_title_lower or \
             ("coordinator" in job_title_lower and ("recruiting" in job_title_lower or "hr" in job_title_lower or "talent" in job_title_lower)) or \
             "talent acquisition coordinator" in job_title_lower or "human resources coordinator" in job_title_lower:
            month1_theme = "Recruiting Fundamentals & Tools Mastery"
            week1_goal = "Understanding the end-to-end recruitment lifecycle and RC role within it. Basics of Applicant Tracking Systems (ATS)."
            week2_goal = "Mastering scheduling tools (Outlook Calendar, Google Calendar) for complex interview arrangements."
            week3_goal = "Professional communication for candidate correspondence (email templates, phone etiquette). Basics of MS Excel/Google Sheets for tracking."
            week4_project = "Project: Create a mock interview schedule for 3 candidates, 5 interviewers with varying availability, and draft all candidate communication."
            month2_theme = "Candidate Experience & Process Efficiency"
            week1_m2 = "Techniques for improving candidate experience at each touchpoint. Handling scheduling conflicts gracefully."
            week2_m2 = "Introduction to data integrity in ATS and importance of accurate record keeping. Generating basic recruitment reports."
            week3_m2 = "Understanding job descriptions and basic screening criteria. Coordinating post-interview debrief logistics."
            week4_project_m2 = "Project: Design a checklist for ensuring a positive candidate experience for a virtual interview process."
            month3_theme = "Advanced Coordination & HR Acumen"
            week1_m3 = "Handling confidential information and understanding basic HR compliance relevant to recruiting."
            week2_m3 = "Time management and prioritization for handling multiple requisitions. Basics of SharePoint or similar for document management."
            week3_m3 = "Problem-solving common recruiting challenges (e.g., last-minute cancellations, unresponsive candidates/managers)."
            capstone_project_m3 = "Capstone: Develop a proposal to improve scheduling efficiency or candidate experience by 10% for the RC team, with actionable steps."
        else: 
            skills_list = [s.strip() for s in skills_for_mock.split(',') if s.strip()]
            month1_theme = "Foundations in Core Professional Skills"
            week1_goal = f"Effective Communication: Written and verbal. (Focus: {skills_list[0] if skills_list else 'Communication'})"
            week2_goal = f"Organizational Skills & Time Management. (Focus: {skills_list[1] if len(skills_list) > 1 else 'Organization'})"
            week3_goal = f"Proficiency in MS Office Suite (Word, Excel, Outlook/PowerPoint) or Google Workspace. (Focus: {skills_list[3] if len(skills_list) > 3 else 'Office Tools'})"
            week4_project = "Project: Organize a mock event/meeting including scheduling, communication, and document preparation."
            month2_theme = "Problem Solving & Process Improvement"
            week1_m2 = "Analytical thinking and problem-solving techniques. (Focus: Problem Solving)"
            week2_m2 = "Introduction to process mapping and identifying areas for efficiency."
            week3_m2 = f"Teamwork and collaboration skills. (Focus: {skills_list[2] if len(skills_list) > 2 else 'Teamwork'})"
            week4_project_m2 = "Project: Identify a common administrative bottleneck and propose a simple solution."
            month3_theme = "Advanced Professional Development"
            week1_m3 = "Developing industry-specific knowledge relevant to the company/role."
            week2_m3 = "Customer service orientation and stakeholder management."
            week3_m3 = "Presentation skills and professional networking basics."
            capstone_project_m3 = "Capstone: Create a professional development plan for yourself targeting a specific career goal within the organization."

        return f"""AI Automation Risk Score: {risk_score}/10

3-Month Personalized Upskilling Roadmap for {job_title_for_mock}:

Month 1: {month1_theme}
- Week 1: {week1_goal}
- Week 2: {week2_goal}
- Week 3: {week3_goal}
- Week 4: {week4_project}

Month 2: {month2_theme}
- Week 1: {week1_m2}
- Week 2: {week2_m2}
- Week 3: {week3_m2}
- Week 4: {week4_project_m2}

Month 3: {month3_theme}
- Week 1: {week1_m3}
- Week 2: {week2_m3}
- Week 3: {week3_m3}
- Week 4: {capstone_project_m3}
"""
    elif "job title" in prompt_lower and "skills" in prompt_lower: 
        job_title_lower = job_title_for_mock.lower()
        if "finance manager" in job_title_lower:
             return "Job Title: Finance Manager\nSkills: Financial Analysis, Forecasting, Budgeting, Excel, Financial Modeling, Reporting, Communication"
        elif "recruiting coordinator" in job_title_lower or ("coordinator" in job_title_lower and "recruiting" in job_title_lower) :
             return "Job Title: Recruiting Coordinator\nSkills: Scheduling, Communication, ATS, Organization, MS Outlook, MS Excel, Candidate Experience, Time Management"
        return f"""Job Title: {job_title_for_mock}
Skills: {skills_for_mock}
"""
    elif "improvements" in prompt_lower:
        job_title_lower = job_title_for_mock.lower()
        improvement_suggestions = [
            f"1. Quantify your achievements with specific numbers and metrics relevant to a {job_title_for_mock} role.",
            f"2. Tailor your skills section to precisely match the requirements typically found in {job_title_for_mock} job descriptions. Highlight transferable skills.",
            f"3. Write a compelling summary or objective statement at the top of your resume, clearly stating your career goal as a {job_title_for_mock} and your key qualifications.",
            "4. Use action verbs to start your bullet points (e.g., Managed, Coordinated, Developed, Implemented).",
            f"5. Ensure your resume is ATS-friendly by using standard fonts, clear section headings, and relevant keywords for a {job_title_for_mock}."
        ]
        if "finance manager" in job_title_lower:
            improvement_suggestions.append("6. Highlight experience with financial modeling, forecasting, budgeting software, and any specific financial regulations you are familiar with.")
        elif "recruiting coordinator" in job_title_lower:
            improvement_suggestions.append("6. Emphasize your organizational skills, experience with scheduling tools (Outlook, Google Calendar), and any familiarity with Applicant Tracking Systems (ATS). Mention specific examples of managing complex schedules or improving candidate experience.")
        elif "data scientist" in job_title_lower or "data analyst" in job_title_lower:
            improvement_suggestions.append("6. Showcase your portfolio of data projects (e.g., on GitHub), and list your proficiency in specific programming languages (Python, R, SQL) and data visualization tools (Tableau, Power BI).")
        
        return "Resume Improvement Suggestions (Mock):\n" + "\n".join(improvement_suggestions)
    else: 
        return f"""Mock Answer for {job_title_for_mock}:
        To build a career as a {job_title_for_mock}, focus on these key areas:
        1. Master the core relevant skills: {skills_for_mock}.
        2. Build practical projects or gain experience relevant to the role.
        3. Network with industry professionals in the {job_title_for_mock} field.
        """

def generate_gemini_content(prompt):
    """Generate content using Gemini API"""
    if use_mock_data:
        return get_mock_llm_response(prompt)
    
    try:
        model = genai.GenerativeModel(
            model_name=model_name,
            generation_config=genai.types.GenerationConfig(
                temperature=temperature,
                max_output_tokens=max_tokens,
            )
        )
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        st.error(f"Gemini content generation error: {str(e)}")
        return get_mock_llm_response(prompt)

def generate_openai_content_direct(prompt):
    """ä½¿ç”¨requestsç›´æ¥è°ƒç”¨OpenAI APIï¼Œç»•è¿‡SDKï¼Œæ¨¡æ‹ŸPostmançš„è¯·æ±‚æ–¹å¼"""
    if use_mock_data:
        return get_mock_llm_response(prompt)
    
    try:
        # æ„å»ºä¸Postmanå®Œå…¨ç›¸åŒçš„è¯·æ±‚
        url = f"{custom_base_url}/v1/chat/completions"
        
        if debug_mode:
            st.write(f"Direct API call to URL: {url}")
            st.write(f"API Key (first 5 chars): {OPENAI_API_KEY[:5]}...")
        
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {OPENAI_API_KEY}"
        }
        
        payload = {
            "model": model_name,
            "messages": [
                {"role": "system", "content": "You are a helpful career coach assistant."},
                {"role": "user", "content": prompt}
            ],
            "temperature": temperature,
            "max_tokens": max_tokens
        }
        
        # å‘é€HTTPè¯·æ±‚ï¼Œä¸Postmanè¡Œä¸ºä¸€è‡´
        response = requests.post(url, headers=headers, json=payload, timeout=30)
        
        # æ£€æŸ¥HTTPçŠ¶æ€ç 
        if response.status_code == 200:
            # æˆåŠŸè·å–å“åº”
            if debug_mode:
                st.success("Direct API call successful!")
                
            result = response.json()
            return result['choices'][0]['message']['content']
        else:
            # APIè¿”å›é”™è¯¯
            error_msg = f"API Error ({response.status_code}): {response.text[:100]}..."
            if debug_mode:
                st.error(error_msg)
            else:
                st.error("API Error. Enable debug mode for details.")
            
            return get_mock_llm_response(prompt)
    except Exception as e:
        st.error(f"Direct request error: {str(e)}")
        return get_mock_llm_response(prompt)

def generate_openai_content(prompt):
    """Generate content using OpenAI API"""
    # ç›´æ¥è°ƒç”¨æ–°çš„ç›´æ¥è¯·æ±‚å‡½æ•°ï¼Œç»•è¿‡SDK
    return generate_openai_content_direct(prompt)
    
    # ä¸‹é¢æ˜¯åŸå§‹çš„SDKå®ç°ï¼Œä¿ç•™ä½†æ³¨é‡Šæ‰ï¼Œä»¥é˜²éœ€è¦åˆ‡æ¢å›æ¥
    """
    if use_mock_data:
        return get_mock_llm_response(prompt)
    
    try:
        response = openai.chat.completions.create(
            model=model_name,
            messages=[
                {"role": "system", "content": "You are a helpful career coach assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=temperature,
            max_tokens=max_tokens
        )
        
        # å¤„ç†å¯èƒ½çš„ä¸åŒå“åº”æ ¼å¼
        if hasattr(response, 'choices'):
            return response.choices[0].message.content
        elif isinstance(response, dict) and 'choices' in response:
            return response['choices'][0]['message']['content']
        elif isinstance(response, str):
            try:
                import json
                data = json.loads(response)
                return data['choices'][0]['message']['content']
            except Exception as json_error:
                st.error(f"OpenAI API Error: Unable to parse response as JSON. The response was: '{response[:100]}...'. Error: {str(json_error)}")
                return get_mock_llm_response(prompt)
        else:
            st.error(f"OpenAI API Error: Unexpected response format: {type(response)}. Response: '{str(response)[:100]}...'")
            return get_mock_llm_response(prompt)
    except Exception as e:
        st.error(f"OpenAI API Error: General content generation error: {str(e)}")
        return get_mock_llm_response(prompt)
    """

def generate_content(prompt):
    """Generate content based on selected API"""
    if api_choice == "Google Gemini":
        return generate_gemini_content(prompt)
    else:
        return generate_openai_content(prompt)

def extract_job_info_with_llm(job_description, force_direct_parsing_flag):
    try:
        if debug_mode:
            st.write("--- Debug: Entering extract_job_info_with_llm ---")
            st.write(f"force_direct_parsing_flag: {force_direct_parsing_flag}") # Log the passed flag
            st.write("Job Description (first 300 chars):", job_description[:300] + "...")

        description_lower = job_description.lower()
        extracted_title = None
        extracted_skills_list = []

        role_patterns = [
            ("recruiting coordinator", "Recruiting Coordinator", ["Scheduling", "Communication", "ATS", "Organization", "MS Outlook", "MS Excel", "Candidate Experience", "Time Management"]),
            (("hr coordinator", "human resources coordinator"), "Human Resources Coordinator", ["HR Administration", "Onboarding", "Employee Records", "Communication", "ATS", "MS Office", "Scheduling", "Problem Solving"]),
            ("talent acquisition coordinator", "Talent Acquisition Coordinator", ["Sourcing Support", "Candidate Engagement", "ATS Management", "Scheduling", "Reporting", "Communication", "Organization"]),
            (("finance manager", "financial manager"), "Finance Manager", ["Financial Analysis", "Forecasting", "Budgeting", "Excel", "Financial Modeling", "Reporting", "Communication", "Business Acumen"]),
            (("data scientist",), "Data Scientist", ["Python", "R", "Machine Learning", "SQL", "Statistics", "Data Visualization", "Big Data", "Predictive Modeling"]),
            (("data analyst",), "Data Analyst", ["SQL", "Excel", "Tableau", "Power BI", "Data Cleaning", "Data Visualization", "Statistics", "Communication"]),
            (("software engineer", "software developer"), "Software Engineer", ["Python", "Java", "JavaScript", "Git", "SQL", "APIs", "Problem Solving", "Data Structures"])
        ]

        for keywords, title, skills in role_patterns:
            if isinstance(keywords, tuple):
                if any(kw in description_lower for kw in keywords):
                    extracted_title = title
                    extracted_skills_list = skills
                    break
            elif keywords in description_lower:
                extracted_title = title
                extracted_skills_list = skills
                break
        
        if debug_mode and extracted_title:
            st.success(f"Direct keyword match successful. Title: {extracted_title}, Skills: {extracted_skills_list}")

        if not extracted_title:
            generic_title_patterns = [
                r'seeking a(?:n)? ([\w\s]+?)(?:\sto|,|\swith|\[|,|\n)',
                r'hiring a(?:n)? ([\w\s]+?)(?:\sto|,|\swith|\[|,|\n)',
                r'is (?:looking|searching) for a(?:n)? ([\w\s]+?)(?:\sto|,|\swith|\[|,|\n)',
                r'job title:?\s*([\w\s(]+?)(?:\n|,|\[)',
                r'role:?\s*([\w\s(]+?)(?:\n|,|\[)', 
                r'position:?\s*([\w\s(]+?)(?:\n|,|\[)'
            ]
            for pattern in generic_title_patterns:
                match = re.search(pattern, description_lower, re.IGNORECASE)
                if match:
                    potential_title = match.group(1).strip()
                    potential_title = re.sub(r'\s*\(.*?\)$' ,'', potential_title).strip()
                    potential_title = re.sub(r'\s+(to|with|for|as a|who|responsible for)$' ,'', potential_title, flags=re.IGNORECASE).strip()
                    if 2 < len(potential_title.split()) < 6 and len(potential_title) < 50:
                        extracted_title = potential_title.title()
                        if debug_mode:
                            st.info(f"Regex pattern matched. Potential Title: {extracted_title}")
                        if not extracted_skills_list:
                            extracted_skills_list = ["Communication", "Problem Solving", "Teamwork", "Organization", "Adaptability"]
                        break
        
        if debug_mode and force_direct_parsing_flag:
             st.warning("Force direct parsing is ON. Skipping LLM call for job info extraction.")
        
        if (force_direct_parsing_flag and extracted_title) or \
           (extracted_title and extracted_skills_list and not force_direct_parsing_flag and api_choice == "OpenAI"): 
            if debug_mode:
                st.success(f"Using directly parsed/keyword-matched job info. Title: {extracted_title}, Skills: {extracted_skills_list}")
            return {
                "job_title": extracted_title,
                "resilient_skills": ", ".join(extracted_skills_list)
            }

        if not extracted_title or not extracted_skills_list or (api_choice == "Google Gemini" and not force_direct_parsing_flag): 
            if debug_mode and (not extracted_title or not extracted_skills_list):
                st.info("Direct parsing failed or incomplete. Attempting LLM extraction...")
            elif debug_mode:
                 st.info("Proceeding with Gemini LLM extraction (or LLM if not forcing direct parse)...")
            prompt_llm = f"""
            Extract the EXACT job title and key skills from the job description below.
            Pay close attention to the actual job title mentioned in the description, not just keywords.
            For financial, management, or non-technical roles, be sure to identify them correctly.
            
            Format your response EXACTLY as follows:
            Job Title: [extracted job title, e.g. Finance Manager, Recruiting Coordinator, Software Engineer, etc.]
            Skills: [comma-separated list of 5-8 key skills required for this role. For 'Recruiting Coordinator', skills should include Scheduling, Communication, ATS, Organization, MS Outlook, MS Excel, Candidate Experience, Time Management.]

            Job Description:
            {job_description}
            """
            
            if debug_mode:
                st.write("LLM Prompt for job info extraction:", prompt_llm)
            
            response_llm = generate_content(prompt_llm)
            
            if debug_mode:
                st.write("Raw LLM response for job info:", response_llm)
            
            job_title_match_llm = re.search(r"Job Title:\s*(.*?)(?:\n|$)", response_llm, re.IGNORECASE)
            skills_match_llm = re.search(r"Skills:\s*(.*?)(?:\n|$)", response_llm, re.IGNORECASE)
            
            llm_job_title = job_title_match_llm.group(1).strip() if job_title_match_llm else None
            llm_skills_text = skills_match_llm.group(1).strip() if skills_match_llm else None
            
            if llm_job_title and llm_skills_text:
                extracted_title = llm_job_title
                extracted_skills_list = [s.strip() for s in llm_skills_text.split(",") if s.strip()]
                if debug_mode:
                    st.success(f"LLM extraction successful. Title: {extracted_title}, Skills: {extracted_skills_list}")
            elif debug_mode:
                st.warning("LLM extraction failed to parse title/skills. Will use fallback.")

        if not extracted_title:
            extracted_title = "General Role"
            if debug_mode:
                st.warning("All extraction methods failed for title. Using 'General Role'.")
        if not extracted_skills_list:
            description_lower = job_description.lower()
            if "finance" in description_lower or "financial" in description_lower:
                extracted_skills_list = ["Financial Analysis", "Forecasting", "Budgeting", "Data Analysis", "Excel"]
            elif "recruiting" in description_lower or "hr" in description_lower or "human resources" in description_lower:
                 extracted_skills_list = ["Scheduling", "Communication", "ATS", "Organization", "MS Office", "Candidate Support"]
            elif "manager" in description_lower or "management" in description_lower:
                extracted_skills_list = ["Leadership", "Strategic Planning", "Team Management", "Communication", "Project Management"]
            else:
                extracted_skills_list = ["Communication", "Problem Solving", "Analytical Skills", "Attention to Detail", "Teamwork"]
            if debug_mode:
                st.warning(f"Using fallback skills for '{extracted_title}': {extracted_skills_list}")

        final_result = {
            "job_title": extracted_title,
            "resilient_skills": ", ".join(extracted_skills_list)
        }
        
        if debug_mode:
            st.write("--- Debug: Exiting extract_job_info_with_llm ---")
            st.json(final_result)
            
        return final_result

    except Exception as e:
        st.error(f"Critical error in extract_job_info_with_llm: {str(e)}")
        return {
            "job_title": "Error Processing Job",
            "resilient_skills": "Error, Issue, Problem"
        }

# --- SAMPLE JOB DATA ---
df_jobs = pd.DataFrame([
    {"job_title": "Software Engineer", "resilient_skills": "Python, API Design, Git"},
    {"job_title": "Data Analyst", "resilient_skills": "SQL, Tableau, Data Cleaning"},
    {"job_title": "Cybersecurity Analyst", "resilient_skills": "Networking, Linux, Threat Modeling"},
])

# --- MODE SELECTION ---
st.markdown("## ğŸ“ Select Mode")
mode = st.radio(
    "Choose how you want to explore career options:",
    ["Mode 1: System Recommendations", "Mode 2: Custom Job Descriptions"]
)

# --- RESUME REQUIREMENT ---
if not uploaded_file:
    st.warning("ğŸ‘† Upload a resume from the sidebar to get started.")
    st.stop()

resume_text = extract_text_from_resume(uploaded_file)
resume_summary = resume_text[:600]
st.subheader("ğŸ“ Resume Extracted Text (Preview)")
st.text_area("Extracted Resume Text", resume_summary, height=300)
resume_embedding = get_text_embedding(resume_summary)

# --- MODE 1: SYSTEM RECOMMENDATIONS ---
if mode == "Mode 1: System Recommendations":
    st.markdown("### ğŸ” System Analyzing Your Resume Against Predefined Roles")
    
    if "job_embedding" not in df_jobs.columns:
        df_jobs["job_embedding"] = df_jobs["job_title"].apply(get_text_embedding)

    df_jobs["similarity"] = df_jobs["job_embedding"].apply(lambda x: cosine_similarity(resume_embedding, x))
    best_match = df_jobs.sort_values(by="similarity", ascending=False).iloc[0]
    
    st.success(f"âœ… Best match found: {best_match['job_title']}")
    
    job_title = best_match['job_title']
    resilient_skills = best_match['resilient_skills']

# --- MODE 2: CUSTOM JOB DESCRIPTIONS ---
else:
    st.markdown("### ğŸ“ Paste Job Descriptions")
    st.info("In Mode 2, you can paste one or more job descriptions to analyze. Separate multiple job descriptions with '---'")
    
    # æ·»åŠ ç¤ºä¾‹æŒ‰é’®
    if st.button("Load Example Job Description"):
        example_job = """
        Job Title: Full Stack Developer
        
        We are looking for a Full Stack Developer who is passionate about building innovative web applications. The ideal candidate should have experience with modern JavaScript frameworks, RESTful APIs, and cloud services.
        
        Requirements:
        - 3+ years of experience with React, Vue, or Angular
        - Strong knowledge of Node.js and Express
        - Experience with SQL and NoSQL databases
        - Familiarity with AWS or Azure cloud services
        - Understanding of CI/CD pipelines
        - Good communication skills
        """
        job_descriptions = st.text_area(
            "Paste one or more job descriptions (separate multiple jobs with '---')",
            value=example_job,
            height=300,
            key="job_input"
        )
    else:
        job_descriptions = st.text_area(
            "Paste one or more job descriptions (separate multiple jobs with '---')",
            height=300,
            placeholder="Paste job description here...\n\n---\n\nNext job description here...",
            key="job_input"
        )
    
    # æ·»åŠ æäº¤æŒ‰é’®ä»¥ä¾¿æ˜ç¡®è§¦å‘åˆ†æ
    analyze_clicked = st.button("Analyze Job Descriptions")
    
    if job_descriptions and analyze_clicked:
        st.info("Processing job descriptions... This may take a moment.")
        
        # Split multiple job descriptions
        job_list = [jd.strip() for jd in job_descriptions.split("---") if jd.strip()]
        
        if not job_list:
            st.error("Please provide at least one job description.")
            st.stop()
        
        # Process each job description
        custom_jobs = []
        progress_bar = st.progress(0)
        
        for i, job_desc in enumerate(job_list):
            with st.spinner(f"Processing job {i+1}/{len(job_list)}..."):
                try:
                    # Ensure force_direct_parsing is correctly passed
                    job_info = extract_job_info_with_llm(job_desc, force_direct_parsing)
                    job_info["job_embedding"] = get_text_embedding(job_desc) 
                    job_info["similarity"] = cosine_similarity(resume_embedding, job_info["job_embedding"])
                    custom_jobs.append(job_info)
                    progress_bar.progress((i + 1) / len(job_list))
                except Exception as e:
                    # Display the actual error to help debug further if needed
                    st.error(f"Error processing job {i+1} ('{job_desc[:50]}...'): {str(e)}")
                    # Add a placeholder or skip this job to avoid crashing the whole loop
                    custom_jobs.append({
                        "job_title": f"Error in Job {i+1}", 
                        "resilient_skills": "Error", 
                        "job_embedding": get_mock_embedding(), # Use mock to prevent further errors
                        "similarity": 0
                    })
        
        progress_bar.empty()
        
        if not custom_jobs:
            st.error("Could not process any of the job descriptions. Please try again.")
            st.stop()
        
        # Create DataFrame from custom jobs
        df_custom_jobs = pd.DataFrame(custom_jobs)
        
        # Display job matches
        st.markdown("### ğŸ” Job Matches")
        for i, job in df_custom_jobs.iterrows():
            st.markdown(f"**Job {i+1}: {job['job_title']}**")
            st.markdown(f"Skills: {job['resilient_skills']}")
            st.markdown(f"Similarity: {round(job['similarity'], 3)}")
            st.markdown("---")
        
        # Select best match or let user choose
        if len(custom_jobs) > 1:
            selected_job_index = st.selectbox(
                "Select a job to analyze further:",
                range(len(custom_jobs)),
                format_func=lambda i: f"{custom_jobs[i]['job_title']} (Match: {round(custom_jobs[i]['similarity'], 2)})"
            )
            best_match = custom_jobs[selected_job_index]
        else:
            best_match = custom_jobs[0]
            
        job_title = best_match['job_title']
        resilient_skills = best_match['resilient_skills']
        
        st.success(f"âœ… Selected job for analysis: {job_title}")
        
        # æ·»åŠ ä¸€ä¸ªæ ‡è®°ï¼Œè¡¨æ˜åˆ†æå·²å®Œæˆ
        st.session_state['job_analysis_complete'] = True
        st.session_state['job_title'] = job_title
        st.session_state['resilient_skills'] = resilient_skills
    elif job_descriptions:
        st.info("Click 'Analyze Job Descriptions' when you're ready to process.")
    else:
        st.warning("Please paste job descriptions to analyze.")
        st.stop()
        
    # æ£€æŸ¥åˆ†ææ˜¯å¦å·²å®Œæˆ
    if not job_descriptions or not analyze_clicked and not st.session_state.get('job_analysis_complete', False):
        st.stop()
    
    # å¦‚æœæœ‰ä¼šè¯çŠ¶æ€ä¿å­˜çš„ç»“æœï¼Œä½¿ç”¨å®ƒä»¬
    if st.session_state.get('job_analysis_complete', False) and not analyze_clicked:
        job_title = st.session_state.get('job_title')
        resilient_skills = st.session_state.get('resilient_skills')
        st.success(f"Using previously analyzed job: {job_title}")

# --- COMMON ANALYSIS FOR BOTH MODES ---
prompt = f"""
You are an expert career coach and curriculum designer specializing in creating highly tailored professional development plans.
Your task is to create a specific and actionable 3-month upskilling roadmap for a candidate aspiring to the "Matched Job Role" by intensely focusing on the "Key Recommended Skills" provided. Additionally, provide an AI automation risk score (1-10) for this role.

**Crucial Instructions for the Roadmap:**
1.  **Role Specificity:** The roadmap MUST be *directly and exclusively* relevant to the "{job_title}". Avoid generic advice.
2.  **Skill Integration:** Each weekly milestone must clearly contribute to learning or applying one or more of the "{resilient_skills}". Mention which skill(s) each week's activity targets.
3.  **Non-Technical Roles:** If "{job_title}" is a non-technical role (e.g., Finance Manager, Marketing Manager, HR Specialist), the roadmap must reflect non-technical skill development, acquisition of industry-specific knowledge, relevant software/tools (e.g., Excel for Finance, Salesforce for Sales), and soft skills pertinent to that role. *Absolutely do NOT provide a software development or generic IT roadmap for non-technical roles.*
4.  **Technical Roles:** If "{job_title}" is a technical role (e.g., Software Engineer, Data Scientist), focus on relevant programming languages, frameworks, tools, and project-based learning that are standard for that role.
5.  **Actionable Milestones:** Weekly goals should be specific, measurable, achievable, relevant, and time-bound (SMART) where possible. Instead of "Learn Python", suggest "Complete a Python basics course focusing on data structures and write 3 simple scripts".
6.  **Consider Resume (Implicitly):** While the resume summary is provided for context on the candidate's background, the roadmap's primary goal is to build proficiency for the "{job_title}" using the "{resilient_skills}".

**Output Format (Strict Adherence Required):**

AI Automation Risk Score: [Score]/10

3-Month Personalized Upskilling Roadmap for {job_title}:

Month 1: [Theme for Month 1 - e.g., "Foundational Financial Acumen & Tools" for a Finance Manager or "Core Python & Data Manipulation" for Data Analyst]
- Week 1: [Specific, actionable goal related to skills for {job_title}]. (Targets: [Skill1, Skill2])
- Week 2: [Specific, actionable goal related to skills for {job_title}]. (Targets: [Skill2, Skill3])
- Week 3: [Specific, actionable goal related to skills for {job_title}]. (Targets: [Skill1, Skill4])
- Week 4: [Mini-project or practical application relevant to {job_title}]. (Integrates: [Skill1, Skill2, Skill3])

Month 2: [Theme for Month 2 - e.g., "Advanced Analysis & Reporting" for Finance or "Statistical Modeling & Machine Learning Basics" for Data Analyst]
- Week 1: [Goal]. (Targets: [SkillX])
- Week 2: [Goal]. (Targets: [SkillY])
- Week 3: [Goal]. (Targets: [SkillZ])
- Week 4: [Project]. (Integrates: [SkillX, SkillY, SkillZ])

Month 3: [Theme for Month 3 - e.g., "Strategic Application & Business Partnering" for Finance or "Specialized Techniques & Deployment" for Data Analyst]
- Week 1: [Goal]. (Targets: [SkillA])
- Week 2: [Goal]. (Targets: [SkillB])
- Week 3: [Goal]. (Targets: [SkillC])
- Week 4: [Capstone project or advanced application for {job_title}, demonstrating overall competency]. (Showcases: All key skills)

--- Context for AI --- 
Resume Summary (for background understanding of candidate's potential starting point):
{resume_summary}

Matched Job Role (The role the roadmap is for):
{job_title}

Key Recommended Skills (The skills the roadmap must focus on):
{resilient_skills}
"""

st.info(f"Generating career analysis with {api_choice}...")

try:
    roadmap_output = generate_content(prompt)
    st.success("Career analysis complete!")
except Exception as e:
    st.error(f"Error generating roadmap: {str(e)}")
    roadmap_output = "Error generating roadmap. Please try again with a different model or settings."

risk_match = re.search(r"risk score.*?(\d{1,2})", roadmap_output, re.IGNORECASE)
risk_score = risk_match.group(1) if risk_match else "N/A"

if debug_mode:
    st.write("--- Debug: Data for Radar Chart --- ")
    st.write(f"Job Title for Analysis: {job_title}")
    st.write(f"Resilient Skills String (to become target_skills): {resilient_skills}")

known_skills = [
    "Python", "Java", "C++", "JavaScript", "SQL", "Git", "Linux", "Networking", "Bash",
    "Tableau", "Excel", "Power BI", "Burp Suite", "Nmap", "Wireshark", "Prompt Engineering",
    "APIs", "Cloud", "Docker", "Kubernetes", "Ethical Hacking", 
    "Communication", "Management", "Financial Analysis", "Reporting", "Data Analysis", 
    "Project Management", "Problem Solving", "Organization", "Scheduling", "ATS", 
    "Candidate Experience", "Time Management", "HR Administration", "Onboarding", "Employee Records",
    "Sourcing Support", "Candidate Engagement", "ATS Management", 
    "Forecasting", "Budgeting", "Financial Modeling", "Business Acumen", 
    "R", "Machine Learning", "Statistics", "Data Visualization", "Big Data", "Predictive Modeling",
    "Data Cleaning", "Teamwork", "Adaptability"
]
user_skills = [skill for skill in known_skills if skill.lower() in resume_text.lower()]
target_skills = [s.strip() for s in resilient_skills.split(",") if s.strip()]

if debug_mode:
    st.write(f"User Skills (from resume & known_skills): {user_skills}")
    st.write(f"Target Skills (parsed from resilient_skills): {target_skills}")
    st.write("--- End Debug --- ")

try:
    plot_skill_gap_chart(user_skills, target_skills)
except Exception as e:
    st.error(f"Error creating skill gap chart: {str(e)}")

st.subheader("ğŸŒŸ Job Analysis Results")
st.markdown(f"**Target Role:** {job_title}")
st.markdown(f"**Recommended Skills:** {resilient_skills}")
st.markdown(f"**AI Automation Risk Score:** {risk_score}/10")

try:
    st.markdown("### ğŸ“ˆ Skill Gap Radar")
    st.image("skill_radar_chart.png")
except Exception as e:
    st.error(f"Error displaying skill chart: {str(e)}")

st.markdown("### ğŸ§  3-Month AI Roadmap")
st.text_area("AI Output:", value=roadmap_output, height=300)

if st.button("ğŸ—•ï¸ Download Career Report"):
    try:
        file_path = generate_pdf_report(
            name="Candidate",
            role=job_title,
            skills=resilient_skills,
            score=risk_score,
            roadmap=roadmap_output
        )
        with open(file_path, "rb") as f:
            st.download_button(
                label="â¬‡ï¸ Click to download PDF",
                data=f,
                file_name="AI_Career_Report.pdf",
                mime="application/pdf"
            )
    except Exception as e:
        st.error(f"Error generating report: {str(e)}")

if st.button("ğŸ” Suggest Resume Improvements"):
    try:
        improve_prompt = f"""
You are a professional resume advisor. Suggest improvements for the following resume content targeting the role of {job_title}:

{resume_summary}
"""
        improvements = generate_content(improve_prompt)
        st.markdown("### âœ¨ Suggested Improvements")
        st.markdown(improvements)
    except Exception as e:
        st.error(f"Error generating resume improvements: {str(e)}")

st.markdown("### ğŸ¤– Career Chatbot (Tutor Mode)")

# å®šä¹‰ä¸€ä¸ªé»˜è®¤çš„é—®é¢˜åˆ—è¡¨ï¼Œåœ¨æ‰€æœ‰æƒ…å†µä¸‹è‡³å°‘æ˜¾ç¤ºè¿™äº›
default_questions = [
    "How can I prepare for a career transition?",
    "What skills should I prioritize developing next?",
    "How can I showcase my existing skills more effectively?",
    "What industry trends should I be aware of?",
    "How can I leverage AI tools in my career development?"
]

# å°è¯•ç”Ÿæˆé’ˆå¯¹æ€§é—®é¢˜ï¼Œä½†å¦‚æœæ¡ä»¶ä¸æ»¡è¶³åˆ™ä½¿ç”¨é»˜è®¤é—®é¢˜
try:
    # æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦çš„ä¸Šä¸‹æ–‡ä¿¡æ¯æ¥ç”Ÿæˆä¸ªæ€§åŒ–é—®é¢˜
    has_context = 'job_title' in locals() and 'resilient_skills' in locals() and 'resume_summary' in locals()
    
    if has_context and len(job_title) > 0:
        # æ ¹æ®ç®€å†å’ŒJDç”Ÿæˆé¢„è®¾é—®é¢˜
        questions_prompt = f"""
        You are a career coach. Based on this person's resume and their target job role, 
        generate 4 specific questions they might want to ask about their career transition.
        Make questions specific to skills they need to develop for {job_title} and any gaps 
        between their current skills and {resilient_skills}.
        
        Resume: {resume_summary}
        Target Job: {job_title}
        Required Skills: {resilient_skills}
        
        Format: Return ONLY a Python list of 4 strings like this:
        ["Question 1?", "Question 2?", "Question 3?", "Question 4?"]
        """
        questions_response = generate_content(questions_prompt)
        
        # è§£æè¿”å›çš„é—®é¢˜åˆ—è¡¨å­—ç¬¦ä¸²ä¸ºå®é™…åˆ—è¡¨
        import ast
        try:
            generated_qs = ast.literal_eval(questions_response)
            # ç¡®ä¿æ ¼å¼æ­£ç¡®
            if isinstance(generated_qs, list) and len(generated_qs) > 0:
                example_qs = generated_qs
            else:
                example_qs = default_questions
        except:
            # è§£æå¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤é—®é¢˜
            example_qs = default_questions
    else:
        # æ²¡æœ‰ä¸Šä¸‹æ–‡æ—¶ä½¿ç”¨é»˜è®¤é—®é¢˜
        example_qs = default_questions
except Exception as e:
    # å‡ºé”™æ—¶ä½¿ç”¨é»˜è®¤é—®é¢˜
    example_qs = default_questions

# åˆå§‹åŒ–session_stateä»¥å­˜å‚¨æ‰€é€‰é—®é¢˜
if 'selected_question' not in st.session_state:
    st.session_state.selected_question = ""

def update_question():
    """å½“é€‰æ‹©é—®é¢˜æ—¶æ›´æ–°session_state"""
    if st.session_state.inspiration_dropdown != "-- Select --":
        st.session_state.selected_question = st.session_state.inspiration_dropdown

# ä½¿ç”¨callbackæ¥å¤„ç†é€‰æ‹©å˜åŒ–
selected_q = st.selectbox(
    "Need inspiration?", 
    ["-- Select --"] + example_qs,
    key="inspiration_dropdown",
    on_change=update_question
)
user_query = st.text_input("Ask a career question:", value=selected_q if selected_q != "-- Select --" else "")

if user_query:
    try:
        tutor_prompt = f"You are a career tutor. Respond in {language}. Answer this question in under 150 words: '{user_query}'"
        tutor_response = generate_content(tutor_prompt)
        st.markdown(f"<div style='background-color:#1e1e1e;padding:10px;border-radius:10px'><b>ğŸ’¡ Career Bot:</b> {tutor_response}</div>", unsafe_allow_html=True)
    except Exception as e:
        st.error(f"Error getting career advice: {str(e)}")